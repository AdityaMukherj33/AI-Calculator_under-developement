{"ast":null,"code":"\"use strict\";\n\n/**\n * An implementation of ODEX, by E. Hairer and G. Wanner, ported from the Fortran ODEX.F.\n * The original work carries the BSD 2-clause license, and so does this.\n *\n * Copyright (c) 2016-2023 Colin Smith.\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n * disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Solver = void 0;\nvar STATE;\n(function (STATE) {\n  STATE[STATE[\"Start\"] = 0] = \"Start\";\n  STATE[STATE[\"BasicIntegrationStep\"] = 1] = \"BasicIntegrationStep\";\n  STATE[STATE[\"ConvergenceStep\"] = 2] = \"ConvergenceStep\";\n  STATE[STATE[\"HopeForConvergence\"] = 3] = \"HopeForConvergence\";\n  STATE[STATE[\"Accept\"] = 4] = \"Accept\";\n  STATE[STATE[\"Reject\"] = 5] = \"Reject\";\n})(STATE || (STATE = {}));\nclass Solver {\n  /**\n   * Construct an integrator for the differential system f (which is a function\n   * expected to take a number and return a vector of numbers $Y = f(x)$.), where\n   * Y is a vector of length `n`.\n   *\n   * Updates to the default options for the integrator may also be given.\n   * Options cannot be changed after the solver is constructed.\n   *\n   * @param f function to integrate\n   * @param n dimension of f's return value\n   * @param options dictionary of option updates\n   */\n  constructor(f, n, options = {}) {\n    this.hMax = 0; // maximum step size chosen for this problem\n    this.nEval = 0; // number of function evaluations done\n    this.t = [];\n    this.err = 0;\n    this.errOld = 1e10;\n    // Step counters\n    this.nStep = 0;\n    this.nAccept = 0;\n    this.nReject = 0;\n    this.iPt = 0;\n    this.options = Object.assign({}, Solver.defaults, options);\n    this.n = n;\n    if (this.options.rawFunction) {\n      this.f = f;\n    } else {\n      this.f = (x, y, yp) => {\n        this.copy(yp, f(x, y, []));\n      };\n    }\n    if (this.options.maxSteps <= 0) throw new Error('maxSteps must be positive');\n    if (this.options.maxExtrapolationColumns <= 2) throw new Error('maxExtrapolationColumns must be > 2');\n    const maxK = this.options.maxExtrapolationColumns;\n    this.options.stepSizeSequence = this.options.stepSizeSequence || (this.options.denseOutput ? 4 : 1);\n    if (this.options.stepSizeSequence <= 3 && this.options.denseOutput) throw new Error('stepSizeSequence incompatible with denseOutput');\n    if (this.options.interpolationFormulaDegree <= 0 || this.options.interpolationFormulaDegree >= 7) throw new Error('bad interpolationFormulaDegree');\n    if (this.options.denseOutput) {\n      if (!Array.isArray(this.options.denseComponents) || this.options.denseComponents.length == 0) {\n        // if user does not specify any denseComponents, request all of them.\n        // Create a new array so that we do not re-use the default empty array.\n        this.options.denseComponents = [];\n        for (let i = 0; i < this.n; ++i) {\n          this.options.denseComponents.push(i);\n        }\n      }\n      for (let c of this.options.denseComponents) {\n        if (c < 0 || c >= this.n) throw new Error('illegal dense component index ' + c);\n      }\n    }\n    if (this.options.uRound <= 1e-35 || this.options.uRound > 1) throw new Error('suspicious value of uRound');\n    const lfSafe = 2 * maxK * maxK + maxK;\n    this.aTol = this.expandToArray(this.options.absoluteTolerance);\n    this.rTol = this.expandToArray(this.options.relativeTolerance);\n    // call to core integrator\n    this.ySafe = Array(maxK);\n    this.fSafe = Array(lfSafe);\n    for (let i = 0; i < this.fSafe.length; ++i) this.fSafe[i] = Array(this.options.denseComponents.length);\n    for (let i = 0; i < this.ySafe.length; ++i) this.ySafe[i] = Array(this.options.denseComponents.length);\n    this.hh = Array(maxK);\n    this.t = Array(maxK);\n    for (let i = 0; i < this.t.length; ++i) this.t[i] = Array(this.n);\n    // Define the step size sequence\n    this.nj = Solver.stepSizeSequence(this.options.stepSizeSequence, maxK);\n    // Define the a[i] for order selection\n    this.a = Array(maxK);\n    this.a[0] = 1 + this.nj[0];\n    for (let i = 1; i < maxK; ++i) {\n      this.a[i] = this.a[i - 1] + this.nj[i];\n    }\n    this.w = Array(maxK);\n    this.w[0] = 0;\n    this.scal = Array(this.n);\n    this.fx = Array(this.n);\n    this.dy = Array(this.n);\n    this.dz = Array(this.n);\n    this.yh1 = Array(this.n);\n    this.yh2 = Array(this.n);\n    this.iPoint = Array(maxK + 1);\n    this.errfac = Array(2 * maxK);\n    const ncom = 2 * this.options.maxExtrapolationColumns + 5 + this.options.denseComponents.length;\n    this.dens = Array(ncom);\n    this.ap = Array(31);\n    this.t0i = Array(this.n);\n    this.posNeg = 1;\n  }\n  /**\n   * Grid is supplied as a ready-made integration callback that manages\n   * the delivery of uniformly-spaced integration points. Essentially it\n   * is transforms the step callback (which is invoked at irregular\n   * intervals due to the adaptive step size of the underlying algorithm\n   * and) into a callback that is invoked at predictable coordinates.\n   * The callback produced by grid also takes care of assembling a solution\n   * vector for each component, rather than leaving it up to the client\n   * to call the interpolating function for each component of the solution.\n   *\n   * All of this is easier to do with the new `integrate` interface.\n   *\n   * @param dt interval between points\n   * @param out user callback function, invoked at uniform intervals\n   * @returns a callback for use with the solve interface\n   */\n  grid(dt, out) {\n    if (!this.options.denseOutput) throw new Error('Must set .denseOutput to true when using grid');\n    const components = this.options.denseComponents;\n    let t;\n    return (xOld, x, y, interpolate) => {\n      t = t !== null && t !== void 0 ? t : xOld;\n      while (t <= x) {\n        const yf = new Array(components.length);\n        for (let i = 0; i < components.length; ++i) yf[i] = interpolate(components[i], t);\n        if (out(t, yf) === false) return false;\n        t += dt;\n      }\n    };\n  }\n  /**\n   * Possibly converts a number to an array sized to the dimension of the\n   * integration problem, containing the supplied number in every slot.\n   *\n   * @param x value\n   * @returns An array [x, x, ...]\n   */\n  expandToArray(x) {\n    // If x is an array, return it. If x is a number, return a new array, sized\n    // to the dimension of the problem, filled with the number@.\n    if (Array.isArray(x)) {\n      return x;\n    } else {\n      return Array(this.n).fill(x, 0);\n    }\n  }\n  copy(a, b) {\n    // Copy the elements of b into a\n    if (a.length !== b.length) {\n      throw new Error('copy used on arrays of differing size');\n    }\n    for (let i = 0; i < a.length; ++i) a[i] = b[i];\n  }\n  /**\n   * This is a dummy function used to fill the dense output function field\n   * of a `SolutionSegment` when dense output is switched off. Throws when\n   * invoked with any arguments.\n   *\n   * @param c component number\n   * @param x independent coordinate value\n   */\n  noDenseOutput(c, x) {\n    throw new Error('denseOutput not enabled for this problem');\n  }\n  // Generate step size sequence and return as an array of length n.\n  static stepSizeSequence(nSeq, n) {\n    const a = Array(n);\n    switch (nSeq) {\n      case 1:\n        for (let i = 0; i < n; ++i) a[i] = 2 * (i + 1);\n        break;\n      case 2:\n        a[0] = 2;\n        for (let i = 1; i < n; ++i) a[i] = 4 * i;\n        break;\n      case 3:\n        a[0] = 2;\n        a[1] = 4;\n        a[2] = 6;\n        for (let i = 3; i < n; ++i) a[i] = 2 * a[i - 2];\n        break;\n      case 4:\n        for (let i = 0; i < n; ++i) a[i] = 4 * i + 2;\n        break;\n      case 5:\n        for (let i = 0; i < n; ++i) a[i] = 4 * (i + 1);\n        break;\n      default:\n        throw new Error('invalid stepSizeSequence selected');\n    }\n    return a;\n  }\n  /**\n   *  Generate interpolation data\n   */\n  interp(y, imit) {\n    // computes the coefficients of the interpolation formula\n    const n = this.options.denseComponents.length;\n    // begin with Hermite interpolation\n    for (let i = 0; i < n; ++i) {\n      const y0 = y[i];\n      const y1 = y[2 * n + i];\n      const yp0 = y[n + i];\n      const yp1 = y[3 * n + i];\n      const yDiff = y1 - y0;\n      const aspl = -yp1 + yDiff;\n      const bspl = yp0 - yDiff;\n      y[n + i] = yDiff;\n      y[2 * n + i] = aspl;\n      y[3 * n + i] = bspl;\n      if (imit < 0) continue;\n      // compute the derivatives of Hermite at midpoint\n      const ph0 = (y0 + y1) * 0.5 + 0.125 * (aspl + bspl);\n      const ph1 = yDiff + (aspl - bspl) * 0.25;\n      const ph2 = -(yp0 - yp1);\n      const ph3 = 6 * (bspl - aspl);\n      // compute the further coefficients\n      if (imit >= 1) {\n        this.ap[1] = 16 * (y[5 * n + i] - ph1);\n        if (imit >= 3) {\n          this.ap[3] = 16 * (y[7 * n + i] - ph3 + 3 * this.ap[1]);\n          if (imit >= 5) {\n            for (let im = 5; im <= imit; im += 2) {\n              let fac1 = im * (im - 1) / 2;\n              let fac2 = fac1 * (im - 2) * (im - 3) * 2;\n              this.ap[im] = 16 * (y[(im + 4) * n + i] + fac1 * this.ap[im - 2] - fac2 * this.ap[im - 4]);\n            }\n          }\n        }\n      }\n      this.ap[0] = (y[4 * n + i] - ph0) * 16;\n      if (imit >= 2) {\n        this.ap[2] = (y[n * 6 + i] - ph2 + this.ap[0]) * 16;\n        if (imit >= 4) {\n          for (let im = 4; im <= imit; im += 2) {\n            let fac1 = im * (im - 1) / 2;\n            let fac2 = im * (im - 1) * (im - 2) * (im - 3);\n            this.ap[im] = (y[n * (im + 4) + i] + this.ap[im - 2] * fac1 - this.ap[im - 4] * fac2) * 16;\n          }\n        }\n      }\n      for (let im = 0; im <= imit; ++im) y[n * (im + 4) + i] = this.ap[im];\n    }\n  }\n  /**\n   * Given interpolation data, produce the dense output function over the solution\n   * segment [xOld, xOld+h].\n   */\n  contex(xOld, h, imit) {\n    const y = this.dens.slice();\n    return (c, x) => {\n      const nrd = this.options.denseComponents.length;\n      let i = this.options.denseComponents.indexOf(c);\n      if (i < 0) throw new Error('no dense output available for component ' + c);\n      const theta = (x - xOld) / h;\n      const theta1 = 1 - theta;\n      const phthet = y[i] + theta * (y[nrd + i] + theta1 * (y[2 * nrd + i] * theta + y[3 * nrd + i] * theta1));\n      if (imit < 0) return phthet;\n      const thetah = theta - 0.5;\n      let ret = y[nrd * (imit + 4) + i];\n      for (let im = imit; im >= 1; --im) {\n        ret = y[nrd * (im + 3) + i] + ret * thetah / im;\n      }\n      return phthet + Math.pow(theta * theta1, 2) * ret;\n    };\n  }\n  /**\n   * Computes the jth line of the extrapolation table (0-based) and\n   * provides an estimation of the optional step size. Returns\n   * false if the Fortran condition \"ATOV\" is true. Not quite\n   * sure what that stands for as of this writing.\n   * @param j\n   * @param h\n   * @param x\n   * @param y\n   * @param yprime\n   * @returns\n   */\n  midEx(j, h, x, y, yprime) {\n    const hj = h / this.nj[j];\n    // Euler starting step\n    for (let i = 0; i < this.n; ++i) {\n      this.yh1[i] = y[i];\n      this.yh2[i] = y[i] + hj * yprime[i];\n    }\n    // Explicit midpoint rule\n    const m = this.nj[j] - 1;\n    const njMid = this.nj[j] / 2 | 0;\n    for (let mm = 1; mm <= m; ++mm) {\n      if (this.options.denseOutput && mm === njMid) {\n        for (let i = 0; i < this.options.denseComponents.length; ++i) {\n          this.ySafe[j][i] = this.yh2[this.options.denseComponents[i]];\n        }\n      }\n      this.f(x + hj * mm, this.yh2, this.dy);\n      if (this.options.denseOutput && Math.abs(mm - njMid) <= 2 * j + 1) {\n        ++this.iPt;\n        for (let i = 0; i < this.options.denseComponents.length; ++i) {\n          this.fSafe[this.iPt - 1][i] = this.dy[this.options.denseComponents[i]];\n        }\n      }\n      for (let i = 0; i < this.n; ++i) {\n        let ys = this.yh1[i];\n        this.yh1[i] = this.yh2[i];\n        this.yh2[i] = ys + 2 * hj * this.dy[i];\n      }\n      if (mm <= this.options.stabilityCheckCount && j < this.options.stabilityCheckTableLines) {\n        // stability check\n        let del1 = 0;\n        for (let i = 0; i < this.n; ++i) {\n          del1 += Math.pow(yprime[i] / this.scal[i], 2);\n        }\n        let del2 = 0;\n        for (let i = 0; i < this.n; ++i) {\n          del2 += Math.pow((this.dy[i] - yprime[i]) / this.scal[i], 2);\n        }\n        const quot = del2 / Math.max(this.options.uRound, del1);\n        if (quot > 4) {\n          ++this.nEval;\n          return false;\n        }\n      }\n    }\n    // final smoothing step\n    this.f(x + h, this.yh2, this.dy);\n    if (this.options.denseOutput && njMid <= 2 * j + 1) {\n      ++this.iPt;\n      for (let i = 0; i < this.options.denseComponents.length; ++i) {\n        this.fSafe[this.iPt - 1][i] = this.dy[this.options.denseComponents[i]];\n      }\n    }\n    for (let i = 0; i < this.n; ++i) {\n      this.t[j][i] = (this.yh1[i] + this.yh2[i] + hj * this.dy[i]) / 2;\n    }\n    this.nEval += this.nj[j];\n    // polynomial extrapolation\n    if (j === 0) return true;\n    let fac;\n    for (let l = j; l > 0; --l) {\n      fac = Math.pow(this.nj[j] / this.nj[l - 1], 2) - 1;\n      for (let i = 0; i < this.n; ++i) {\n        this.t[l - 1][i] = this.t[l][i] + (this.t[l][i] - this.t[l - 1][i]) / fac;\n      }\n    }\n    this.err = 0;\n    // scaling\n    for (let i = 0; i < this.n; ++i) {\n      let t0i = Math.max(Math.abs(y[i]), Math.abs(this.t[0][i]));\n      this.scal[i] = this.aTol[i] + this.rTol[i] * t0i;\n      this.err += Math.pow((this.t[0][i] - this.t[1][i]) / this.scal[i], 2);\n    }\n    this.err = Math.sqrt(this.err / this.n);\n    if (this.err * this.options.uRound >= 1 || j > 1 && this.err >= this.errOld) {\n      return false;\n    }\n    this.errOld = Math.max(4 * this.err, 1);\n    // compute optimal stepsizes\n    let exp0 = 1 / (2 * j + 1);\n    let facMin = Math.pow(this.options.stepSizeFac1, exp0);\n    fac = Math.min(this.options.stepSizeFac2 / facMin, Math.max(facMin, Math.pow(this.err / this.options.stepSafetyFactor1, exp0) / this.options.stepSafetyFactor2));\n    fac = 1 / fac;\n    this.hh[j] = Math.min(Math.abs(h) * fac, this.hMax);\n    this.w[j] = this.a[j] / this.hh[j];\n    return true;\n  }\n  /**\n   * Considers accepting the current integration step, and, if dense output is\n   * requested, prepares the data that will be used by the interpolating function.\n   * If denseOutputErrorEstimator is also switched on, information gathered\n   * while preparing the dense output data may be used to tardily decide that\n   * the step should be rejected after all.\n   *\n   * @returns an object with the new optimized step size and either a dense\n   *     interpolation function or an indication that the step should be\n   *     rejected after all.\n   */\n  acceptStep(kc, h, x, y, dz) {\n    // label 60\n    const kmit = 2 * kc - this.options.interpolationFormulaDegree + 1;\n    let newHoptde = undefined;\n    if (this.options.denseOutput) {\n      const nrd = this.options.denseComponents.length;\n      // kmit = mu of the paper\n      for (let i = 0; i < nrd; ++i) this.dens[i] = y[this.options.denseComponents[i]];\n      for (let i = 0; i < nrd; ++i) this.dens[nrd + i] = h * dz[this.options.denseComponents[i]];\n      let kln = 2 * nrd;\n      for (let i = 0; i < nrd; ++i) this.dens[kln + i] = this.t[0][this.options.denseComponents[i]];\n      // compute solution at mid-point\n      for (let j = 2; j <= kc; ++j) {\n        for (let l = j; l >= 2; --l) {\n          let factor = Math.pow(this.nj[j - 1] / this.nj[l - 2], 2) - 1;\n          for (let i = 0; i < nrd; ++i) {\n            this.ySafe[l - 2][i] = this.ySafe[l - 1][i] + (this.ySafe[l - 1][i] - this.ySafe[l - 2][i]) / factor;\n          }\n        }\n      }\n      let krn = 4 * nrd;\n      for (let i = 0; i < nrd; ++i) this.dens[krn + i] = this.ySafe[0][i];\n      // compute first derivative at right end\n      for (let i = 0; i < this.n; ++i) this.t0i[i] = this.t[0][i];\n      this.f(x + h, this.t0i, this.fx);\n      krn = 3 * nrd;\n      for (let i = 0; i < nrd; ++i) this.dens[krn + i] = this.fx[this.options.denseComponents[i]] * h;\n      // THE LOOP\n      for (let kmi = 1; kmi <= kmit; ++kmi) {\n        // compute kmi-th derivative at mid-point\n        let kbeg = (kmi + 1) / 2 | 0;\n        for (let kk = kbeg; kk <= kc; ++kk) {\n          let facnj = Math.pow(this.nj[kk - 1] / 2, kmi - 1);\n          this.iPt = this.iPoint[kk] - 2 * kk + kmi;\n          for (let i = 0; i < nrd; ++i) {\n            this.ySafe[kk - 1][i] = this.fSafe[this.iPt - 1][i] * facnj; // TODO warning: if we change definition of iPoint, need to fix this\n          }\n        }\n        for (let j = kbeg + 1; j <= kc; ++j) {\n          for (let l = j; l >= kbeg + 1; --l) {\n            let factor = Math.pow(this.nj[j - 1] / this.nj[l - 2], 2) - 1;\n            for (let i = 0; i < nrd; ++i) {\n              this.ySafe[l - 2][i] = this.ySafe[l - 1][i] + (this.ySafe[l - 1][i] - this.ySafe[l - 2][i]) / factor;\n            }\n          }\n        }\n        krn = (kmi + 4) * nrd;\n        for (let i = 0; i < nrd; ++i) this.dens[krn + i] = this.ySafe[kbeg - 1][i] * h;\n        if (kmi === kmit) continue;\n        // compute differences\n        for (let kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n          let lbeg = this.iPoint[kk];\n          let lend = this.iPoint[kk - 1] + kmi + 1;\n          if (kmi === 1 && this.options.stepSizeSequence === 4) lend += 2;\n          let l;\n          for (l = lbeg; l >= lend; l -= 2) {\n            for (let i = 0; i < nrd; ++i) {\n              this.fSafe[l - 1][i] -= this.fSafe[l - 3][i];\n            }\n          }\n          if (kmi === 1 && this.options.stepSizeSequence === 4) {\n            l = lend - 2;\n            for (let i = 0; i < nrd; ++i) this.fSafe[l - 1][i] -= dz[this.options.denseComponents[i]];\n          }\n        }\n        // compute differences\n        for (let kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n          let lbeg = this.iPoint[kk] - 1;\n          let lend = this.iPoint[kk - 1] + kmi + 2;\n          for (let l = lbeg; l >= lend; l -= 2) {\n            for (let i = 0; i < nrd; ++i) {\n              this.fSafe[l - 1][i] -= this.fSafe[l - 3][i];\n            }\n          }\n        }\n      }\n      this.interp(this.dens, kmit);\n      // estimation of interpolation error\n      if (this.options.denseOutputErrorEstimator && kmit >= 1) {\n        let errint = 0;\n        for (let i = 0; i < nrd; ++i) errint += Math.pow(this.dens[(kmit + 4) * nrd + i] / this.scal[this.options.denseComponents[i]], 2);\n        errint = Math.sqrt(errint / nrd) * this.errfac[kmit - 1];\n        newHoptde = h / Math.max(Math.pow(errint, 1 / (kmit + 4)), 0.01);\n        if (errint > 10) {\n          ++this.nReject;\n          return {\n            accept: false,\n            hoptde: newHoptde\n          };\n        }\n      }\n      this.copy(dz, this.fx);\n    }\n    this.copy(y, this.t[0]);\n    ++this.nAccept;\n    return {\n      accept: true,\n      hoptde: newHoptde,\n      densef: this.options.denseOutput ? this.contex(x, h, kmit) : this.noDenseOutput\n    };\n  }\n  /**\n   * Compute new \"optimal\" extrapolation order and step size based on current\n   * integration conditions recorded in the work array `w`.\n   *\n   * @param reject true if the previous integration step was rejected\n   * @param kc current extrapolation column\n   * @param k extrapolation columns\n   * @param h previous step size\n   * @returns An object holding new step size and extrapolation order\n   */\n  newOrderAndStepSize(reject, kc, k, h) {\n    // compute optimal interpolation order\n    let kopt;\n    if (kc === 2) {\n      kopt = Math.min(3, this.options.maxExtrapolationColumns - 1);\n      if (reject) kopt = 2;\n    } else if (kc <= k) {\n      kopt = kc;\n      if (this.w[kc - 2] < this.w[kc - 1] * this.options.stepSizeFac3) kopt = kc - 1;\n      if (this.w[kc - 1] < this.w[kc - 2] * this.options.stepSizeFac4) kopt = Math.min(kc + 1, this.options.maxExtrapolationColumns - 1);\n    } else {\n      kopt = kc - 1;\n      if (kc > 3 && this.w[kc - 3] < this.w[kc - 2] * this.options.stepSizeFac3) kopt = kc - 2;\n      if (this.w[kc - 1] < this.w[kopt - 1] * this.options.stepSizeFac4) kopt = Math.min(kc, this.options.maxExtrapolationColumns - 1);\n    }\n    // after a rejected step\n    if (reject) {\n      return {\n        k: Math.min(kopt, kc),\n        h: this.posNeg * Math.min(Math.abs(h), Math.abs(this.hh[k - 1]))\n      };\n    }\n    let r = {\n      h: 0,\n      k: 0\n    };\n    if (kopt <= kc) {\n      r.h = this.hh[kopt - 1];\n    } else {\n      if (kc < k && this.w[kc - 1] < this.w[kc - 2] * this.options.stepSizeFac4) {\n        r.h = this.hh[kc - 1] * this.a[kopt] / this.a[kc - 1];\n      } else {\n        r.h = this.hh[kc - 1] * this.a[kopt - 1] / this.a[kc - 1];\n      }\n    }\n    r.h = this.posNeg * Math.abs(r.h);\n    r.k = kopt;\n    return r;\n  }\n  /**\n   * Legacy interface, which delivers solution segments via callback.\n   * The callback will be invoked with the values `xOld`, `x`, `y`, and\n   * `f`. This represents the integration step of the interval `[xOld, x]`,\n   * where $y$ is the integrated value of $f(x)$, and (if dense output was\n   * requested) `f` can be used to obtain high quality results for $f(x)$\n   * anywhere in the interval `[xOld, x]`. It is illegal to use f outside\n   * this range.\n   *\n   * @param x0 initial independent variable\n   * @param y0 f(x0)\n   * @param xEnd end of integration interval\n   * @param solOut optional solution segment callback, or step handler\n   * @returns an object containing summary information about the integration\n   */\n  solve(x0, y0, xEnd, solOut) {\n    if (this.options.denseOutput && !solOut) throw new Error('solve: denseOutput requires a solution observer function');\n    let lastY = y0;\n    for (let segment of this.solutionSegments(x0, y0, xEnd)) {\n      if (solOut) {\n        solOut(segment.x0, segment.x1, segment.y, segment.f);\n      }\n      lastY = segment.y;\n    }\n    return {\n      y: lastY,\n      nStep: this.nStep,\n      xEnd: xEnd,\n      nAccept: this.nAccept,\n      nReject: this.nReject,\n      nEval: this.nEval\n    };\n  }\n  /**\n   * Integrate the differential equation. This produces a function which will\n   * interpolate the solution as far as desired (starting at the point where\n   * the initial conditions are provided). The function must be invoked on an\n   * increasing sequence of x values: you cannot rewind the integration to an\n   * earlier point. (Behind the scenes, a variable step size integration\n   * algorithm is generating solution segments valid on finite intervals. As\n   * you move into a new interval, older intervals are discarded, allowing the\n   * integration to proceed indefinitely without accumulating memory).\n   *\n   * You can signal that you are through with the integrator by calling the\n   * interpolator function with no arguments.\n   *\n   * @param x0 initial independent variable\n   * @param y0 f(x0)\n   * @return interpolation function valid on a monotonically increasing\n   *     argument sequence\n   */\n  integrate(x0, y0) {\n    if (!this.options.denseOutput) throw new Error('integrate interface requires denseOutput');\n    const components = this.options.denseComponents;\n    const segments = this.solutionSegments(x0, y0);\n    let s = segments.next();\n    let closed = false;\n    return (x, v) => {\n      if (x === undefined) {\n        segments.next(false);\n        closed = true;\n        return [];\n      } else if (x < s.value.x0) {\n        throw new Error('cannot use interpolation function in backwards direction');\n      } else if (closed) {\n        throw new Error('cannot use interpolation function after closing integrator');\n      } else {\n        while (!s.done && x > s.value.x1) s = segments.next();\n        if (v !== undefined) {\n          for (let i = 0; i < components.length; ++i) v[i] = s.value.f(components[i], x);\n          return v;\n        } else {\n          let w = Array(components.length);\n          for (let i = 0; i < components.length; ++i) w[i] = s.value.f(components[i], x);\n          return w;\n        }\n      }\n    };\n  }\n  /**\n   * Integrate the differential system represented by f, given initial\n   * values x and y0 = f(x). This generates a contiguous sequence of\n   * solution segments. Each segment contains an interval [x0, x1] and\n   * the integrated value f(x1). If denseOutput is selected in the options,\n   * an interpolation function is provided, valid over the closed interval.\n   *\n   * @param x initial independent coordinate\n   * @param y0 initial value\n   * @param xEnd optional end of integration interval\n   * @return generates a sequence of objects containing x0, x1, y and f properties\n   */\n  *solutionSegments(x, y0, xEnd) {\n    var _a, _b;\n    if (!Array.isArray(y0) || y0.length != this.n) throw new Error('y0 must be an array sized to the dimension of the problem');\n    let y = y0.slice();\n    this.hMax = this.options.maxStepSize;\n    if (this.options.maxStepSize) {\n      this.hMax = this.options.maxStepSize;\n    } else if (xEnd) {\n      this.hMax = Math.abs(xEnd - x);\n    } else {\n      this.hMax = 1;\n    }\n    this.nStep = this.nAccept = this.nReject = 0;\n    this.posNeg = xEnd ? xEnd - x >= 0 ? 1 : -1 : 1;\n    // Initial Scaling\n    for (let i = 0; i < this.n; ++i) {\n      this.scal[i] = this.aTol[i] + this.rTol[i] + Math.abs(y[i]);\n    }\n    // Initial preparations\n    let k = Math.max(2, Math.min(this.options.maxExtrapolationColumns - 1, Math.floor(-Math.log10(this.rTol[0] + 1e-40) * 0.6 + 1.5)));\n    let h = Math.max(Math.abs(this.options.initialStepSize), 1e-4);\n    h = this.posNeg * Math.min(h, this.hMax, xEnd ? Math.abs(xEnd - x) / 2 : Infinity);\n    let xOld = x;\n    this.iPt = 0; // TODO: fix\n    if (this.options.denseOutput) {\n      this.iPoint[0] = 0;\n      for (let i = 0; i < this.options.maxExtrapolationColumns; ++i) {\n        let njAdd = 4 * (i + 1) - 2;\n        if (this.nj[i] > njAdd) ++njAdd;\n        this.iPoint[i + 1] = this.iPoint[i] + njAdd;\n      }\n      for (let mu = 0; mu < 2 * this.options.maxExtrapolationColumns; ++mu) {\n        let errx = Math.sqrt((mu + 1) / (mu + 5)) * 0.5;\n        let prod = Math.pow(1 / (mu + 5), 2);\n        for (let j = 1; j <= mu + 1; ++j) prod *= errx / j;\n        this.errfac[mu] = prod;\n      }\n    }\n    this.err = 0;\n    this.errOld = 1e10;\n    let hoptde = this.posNeg * this.hMax;\n    let reject = false;\n    let last = false;\n    let kc = 0;\n    let state = STATE.Start;\n    loop: while (true) {\n      this.options.debug && console.log(`#${this.nStep} ${STATE[state]} [${xOld},${x}] h=${h} k=${k}`);\n      switch (state) {\n        case STATE.Start:\n          if (xEnd !== undefined) {\n            // Is xEnd reached in the next step?\n            if (0.1 * Math.abs(xEnd - x) <= Math.abs(x) * this.options.uRound) break loop;\n            h = this.posNeg * Math.min(Math.abs(h), Math.abs(xEnd - x), this.hMax, Math.abs(hoptde));\n            if ((x + 1.01 * h - xEnd) * this.posNeg > 0) {\n              h = xEnd - x;\n              last = true;\n            }\n          } else {\n            h = this.posNeg * Math.min(Math.abs(h), this.hMax, Math.abs(hoptde));\n          }\n          if (this.nStep === 0 || !this.options.denseOutput) {\n            this.f(x, y, this.dz);\n            ++this.nEval;\n          }\n          // The first and last step\n          if (this.nStep === 0 || last) {\n            this.iPt = 0;\n            ++this.nStep;\n            for (let j = 1; j <= k; ++j) {\n              kc = j;\n              if (!this.midEx(j - 1, h, x, y, this.dz)) {\n                h *= this.options.stepSizeReductionFactor;\n                reject = true;\n                continue loop;\n              }\n              if (j > 1 && this.err <= 1) {\n                state = STATE.Accept;\n                continue loop;\n              }\n            }\n            state = STATE.HopeForConvergence;\n            continue;\n          }\n          state = STATE.BasicIntegrationStep;\n          continue;\n        case STATE.BasicIntegrationStep:\n          // basic integration step\n          this.iPt = 0;\n          if (++this.nStep >= this.options.maxSteps) {\n            throw new Error('maximum allowed steps exceeded: ' + this.nStep);\n          }\n          kc = k - 1;\n          for (let j = 0; j < kc; ++j) {\n            if (!this.midEx(j, h, x, y, this.dz)) {\n              h *= this.options.stepSizeReductionFactor;\n              reject = true;\n              state = STATE.Start;\n              continue loop;\n            }\n          }\n          // convergence monitor\n          if (k === 2 || reject) {\n            state = STATE.ConvergenceStep;\n          } else {\n            if (this.err <= 1) {\n              state = STATE.Accept;\n            } else if (this.err > Math.pow(this.nj[k] * this.nj[k - 1] / 4, 2)) {\n              state = STATE.Reject;\n            } else state = STATE.ConvergenceStep;\n          }\n          continue;\n        case STATE.ConvergenceStep:\n          // label 50\n          if (!this.midEx(k - 1, h, x, y, this.dz)) {\n            h *= this.options.stepSizeReductionFactor;\n            reject = true;\n            state = STATE.Start;\n            continue;\n          }\n          kc = k;\n          if (this.err <= 1) {\n            state = STATE.Accept;\n            continue;\n          }\n          state = STATE.HopeForConvergence;\n          continue;\n        case STATE.HopeForConvergence:\n          // hope for convergence in line k + 1\n          if (this.err > Math.pow(this.nj[k] / 2, 2)) {\n            state = STATE.Reject;\n            continue;\n          }\n          kc = k + 1;\n          if (!this.midEx(kc - 1, h, x, y, this.dz)) {\n            h *= this.options.stepSizeReductionFactor;\n            reject = true;\n            state = STATE.Start;\n          } else if (this.err > 1) state = STATE.Reject;else state = STATE.Accept;\n          continue;\n        case STATE.Accept:\n          const result = this.acceptStep(kc, h, x, y, this.dz);\n          state = STATE.Start;\n          hoptde = (_a = result.hoptde) !== null && _a !== void 0 ? _a : hoptde;\n          if (!result.accept) {\n            h = hoptde;\n            reject = true;\n            continue;\n          }\n          // Move forward\n          xOld = x;\n          x += h;\n          const proceed = yield {\n            x0: xOld,\n            x1: x,\n            y: y.slice(),\n            f: (_b = result.densef) !== null && _b !== void 0 ? _b : this.noDenseOutput\n          };\n          if (proceed === false) {\n            // Client has signaled that they are through with the integration\n            // and so no further segments will be needed.\n            return;\n          }\n          ({\n            k,\n            h\n          } = this.newOrderAndStepSize(reject, kc, k, h));\n          reject = false;\n          continue;\n        case STATE.Reject:\n          k = Math.min(k, kc, this.options.maxExtrapolationColumns - 1);\n          if (k > 2 && this.w[k - 1] < this.w[k] * this.options.stepSizeFac3) k -= 1;\n          ++this.nReject;\n          h = this.posNeg * this.hh[k - 1];\n          reject = true;\n          state = STATE.BasicIntegrationStep;\n      }\n    }\n  }\n}\nexports.Solver = Solver;\nSolver.defaults = {\n  uRound: 2.3e-16,\n  maxSteps: 10000,\n  initialStepSize: 1e-4,\n  maxStepSize: 0,\n  maxExtrapolationColumns: 9,\n  stepSizeSequence: 0,\n  stabilityCheckCount: 1,\n  stabilityCheckTableLines: 2,\n  denseOutput: true,\n  denseOutputErrorEstimator: true,\n  denseComponents: [],\n  interpolationFormulaDegree: 4,\n  stepSizeReductionFactor: 0.5,\n  stepSizeFac1: 0.02,\n  stepSizeFac2: 4.0,\n  stepSizeFac3: 0.8,\n  stepSizeFac4: 0.9,\n  stepSafetyFactor1: 0.65,\n  stepSafetyFactor2: 0.94,\n  relativeTolerance: 1e-5,\n  absoluteTolerance: 1e-5,\n  debug: false,\n  rawFunction: false\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","Solver","STATE","constructor","f","n","options","hMax","nEval","t","err","errOld","nStep","nAccept","nReject","iPt","assign","defaults","rawFunction","x","y","yp","copy","maxSteps","Error","maxExtrapolationColumns","maxK","stepSizeSequence","denseOutput","interpolationFormulaDegree","Array","isArray","denseComponents","length","i","push","c","uRound","lfSafe","aTol","expandToArray","absoluteTolerance","rTol","relativeTolerance","ySafe","fSafe","hh","nj","a","w","scal","fx","dy","dz","yh1","yh2","iPoint","errfac","ncom","dens","ap","t0i","posNeg","grid","dt","out","components","xOld","interpolate","yf","fill","b","noDenseOutput","nSeq","interp","imit","y0","y1","yp0","yp1","yDiff","aspl","bspl","ph0","ph1","ph2","ph3","im","fac1","fac2","contex","h","slice","nrd","indexOf","theta","theta1","phthet","thetah","ret","Math","pow","midEx","j","yprime","hj","m","njMid","mm","abs","ys","stabilityCheckCount","stabilityCheckTableLines","del1","del2","quot","max","fac","l","sqrt","exp0","facMin","stepSizeFac1","min","stepSizeFac2","stepSafetyFactor1","stepSafetyFactor2","acceptStep","kc","kmit","newHoptde","undefined","kln","factor","krn","kmi","kbeg","kk","facnj","lbeg","lend","denseOutputErrorEstimator","errint","accept","hoptde","densef","newOrderAndStepSize","reject","k","kopt","stepSizeFac3","stepSizeFac4","r","solve","x0","xEnd","solOut","lastY","segment","solutionSegments","x1","integrate","segments","s","next","closed","v","done","_a","_b","maxStepSize","floor","log10","initialStepSize","Infinity","njAdd","mu","errx","prod","last","state","Start","loop","debug","console","log","stepSizeReductionFactor","Accept","HopeForConvergence","BasicIntegrationStep","ConvergenceStep","Reject","result","proceed"],"sources":["C:/Users/ddas0/OneDrive/Desktop/AI Calc/node_modules/odex/src/odex.js"],"sourcesContent":["\"use strict\";\n/**\n * An implementation of ODEX, by E. Hairer and G. Wanner, ported from the Fortran ODEX.F.\n * The original work carries the BSD 2-clause license, and so does this.\n *\n * Copyright (c) 2016-2023 Colin Smith.\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n * disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Solver = void 0;\nvar STATE;\n(function (STATE) {\n    STATE[STATE[\"Start\"] = 0] = \"Start\";\n    STATE[STATE[\"BasicIntegrationStep\"] = 1] = \"BasicIntegrationStep\";\n    STATE[STATE[\"ConvergenceStep\"] = 2] = \"ConvergenceStep\";\n    STATE[STATE[\"HopeForConvergence\"] = 3] = \"HopeForConvergence\";\n    STATE[STATE[\"Accept\"] = 4] = \"Accept\";\n    STATE[STATE[\"Reject\"] = 5] = \"Reject\";\n})(STATE || (STATE = {}));\nclass Solver {\n    /**\n     * Construct an integrator for the differential system f (which is a function\n     * expected to take a number and return a vector of numbers $Y = f(x)$.), where\n     * Y is a vector of length `n`.\n     *\n     * Updates to the default options for the integrator may also be given.\n     * Options cannot be changed after the solver is constructed.\n     *\n     * @param f function to integrate\n     * @param n dimension of f's return value\n     * @param options dictionary of option updates\n     */\n    constructor(f, n, options = {}) {\n        this.hMax = 0; // maximum step size chosen for this problem\n        this.nEval = 0; // number of function evaluations done\n        this.t = [];\n        this.err = 0;\n        this.errOld = 1e10;\n        // Step counters\n        this.nStep = 0;\n        this.nAccept = 0;\n        this.nReject = 0;\n        this.iPt = 0;\n        this.options = Object.assign({}, Solver.defaults, options);\n        this.n = n;\n        if (this.options.rawFunction) {\n            this.f = f;\n        }\n        else {\n            this.f = (x, y, yp) => {\n                this.copy(yp, f(x, y, []));\n            };\n        }\n        if (this.options.maxSteps <= 0)\n            throw new Error('maxSteps must be positive');\n        if (this.options.maxExtrapolationColumns <= 2)\n            throw new Error('maxExtrapolationColumns must be > 2');\n        const maxK = this.options.maxExtrapolationColumns;\n        this.options.stepSizeSequence = this.options.stepSizeSequence || (this.options.denseOutput ? 4 : 1);\n        if (this.options.stepSizeSequence <= 3 && this.options.denseOutput)\n            throw new Error('stepSizeSequence incompatible with denseOutput');\n        if (this.options.interpolationFormulaDegree <= 0 || this.options.interpolationFormulaDegree >= 7)\n            throw new Error('bad interpolationFormulaDegree');\n        if (this.options.denseOutput) {\n            if (!Array.isArray(this.options.denseComponents) || this.options.denseComponents.length == 0) {\n                // if user does not specify any denseComponents, request all of them.\n                // Create a new array so that we do not re-use the default empty array.\n                this.options.denseComponents = [];\n                for (let i = 0; i < this.n; ++i) {\n                    this.options.denseComponents.push(i);\n                }\n            }\n            for (let c of this.options.denseComponents) {\n                if (c < 0 || c >= this.n)\n                    throw new Error('illegal dense component index ' + c);\n            }\n        }\n        if (this.options.uRound <= 1e-35 || this.options.uRound > 1)\n            throw new Error('suspicious value of uRound');\n        const lfSafe = 2 * maxK * maxK + maxK;\n        this.aTol = this.expandToArray(this.options.absoluteTolerance);\n        this.rTol = this.expandToArray(this.options.relativeTolerance);\n        // call to core integrator\n        this.ySafe = Array(maxK);\n        this.fSafe = Array(lfSafe);\n        for (let i = 0; i < this.fSafe.length; ++i)\n            this.fSafe[i] = Array(this.options.denseComponents.length);\n        for (let i = 0; i < this.ySafe.length; ++i)\n            this.ySafe[i] = Array(this.options.denseComponents.length);\n        this.hh = Array(maxK);\n        this.t = Array(maxK);\n        for (let i = 0; i < this.t.length; ++i)\n            this.t[i] = Array(this.n);\n        // Define the step size sequence\n        this.nj = Solver.stepSizeSequence(this.options.stepSizeSequence, maxK);\n        // Define the a[i] for order selection\n        this.a = Array(maxK);\n        this.a[0] = 1 + this.nj[0];\n        for (let i = 1; i < maxK; ++i) {\n            this.a[i] = this.a[i - 1] + this.nj[i];\n        }\n        this.w = Array(maxK);\n        this.w[0] = 0;\n        this.scal = Array(this.n);\n        this.fx = Array(this.n);\n        this.dy = Array(this.n);\n        this.dz = Array(this.n);\n        this.yh1 = Array(this.n);\n        this.yh2 = Array(this.n);\n        this.iPoint = Array(maxK + 1);\n        this.errfac = Array(2 * maxK);\n        const ncom = (2 * this.options.maxExtrapolationColumns + 5) + this.options.denseComponents.length;\n        this.dens = Array(ncom);\n        this.ap = Array(31);\n        this.t0i = Array(this.n);\n        this.posNeg = 1;\n    }\n    /**\n     * Grid is supplied as a ready-made integration callback that manages\n     * the delivery of uniformly-spaced integration points. Essentially it\n     * is transforms the step callback (which is invoked at irregular\n     * intervals due to the adaptive step size of the underlying algorithm\n     * and) into a callback that is invoked at predictable coordinates.\n     * The callback produced by grid also takes care of assembling a solution\n     * vector for each component, rather than leaving it up to the client\n     * to call the interpolating function for each component of the solution.\n     *\n     * All of this is easier to do with the new `integrate` interface.\n     *\n     * @param dt interval between points\n     * @param out user callback function, invoked at uniform intervals\n     * @returns a callback for use with the solve interface\n     */\n    grid(dt, out) {\n        if (!this.options.denseOutput)\n            throw new Error('Must set .denseOutput to true when using grid');\n        const components = this.options.denseComponents;\n        let t;\n        return (xOld, x, y, interpolate) => {\n            t = t !== null && t !== void 0 ? t : xOld;\n            while (t <= x) {\n                const yf = new Array(components.length);\n                for (let i = 0; i < components.length; ++i)\n                    yf[i] = interpolate(components[i], t);\n                if (out(t, yf) === false)\n                    return false;\n                t += dt;\n            }\n        };\n    }\n    /**\n     * Possibly converts a number to an array sized to the dimension of the\n     * integration problem, containing the supplied number in every slot.\n     *\n     * @param x value\n     * @returns An array [x, x, ...]\n     */\n    expandToArray(x) {\n        // If x is an array, return it. If x is a number, return a new array, sized\n        // to the dimension of the problem, filled with the number@.\n        if (Array.isArray(x)) {\n            return x;\n        }\n        else {\n            return Array(this.n).fill(x, 0);\n        }\n    }\n    copy(a, b) {\n        // Copy the elements of b into a\n        if (a.length !== b.length) {\n            throw new Error('copy used on arrays of differing size');\n        }\n        for (let i = 0; i < a.length; ++i)\n            a[i] = b[i];\n    }\n    /**\n     * This is a dummy function used to fill the dense output function field\n     * of a `SolutionSegment` when dense output is switched off. Throws when\n     * invoked with any arguments.\n     *\n     * @param c component number\n     * @param x independent coordinate value\n     */\n    noDenseOutput(c, x) {\n        throw new Error('denseOutput not enabled for this problem');\n    }\n    // Generate step size sequence and return as an array of length n.\n    static stepSizeSequence(nSeq, n) {\n        const a = Array(n);\n        switch (nSeq) {\n            case 1:\n                for (let i = 0; i < n; ++i)\n                    a[i] = 2 * (i + 1);\n                break;\n            case 2:\n                a[0] = 2;\n                for (let i = 1; i < n; ++i)\n                    a[i] = 4 * i;\n                break;\n            case 3:\n                a[0] = 2;\n                a[1] = 4;\n                a[2] = 6;\n                for (let i = 3; i < n; ++i)\n                    a[i] = 2 * a[i - 2];\n                break;\n            case 4:\n                for (let i = 0; i < n; ++i)\n                    a[i] = 4 * i + 2;\n                break;\n            case 5:\n                for (let i = 0; i < n; ++i)\n                    a[i] = 4 * (i + 1);\n                break;\n            default:\n                throw new Error('invalid stepSizeSequence selected');\n        }\n        return a;\n    }\n    /**\n     *  Generate interpolation data\n     */\n    interp(y, imit) {\n        // computes the coefficients of the interpolation formula\n        const n = this.options.denseComponents.length;\n        // begin with Hermite interpolation\n        for (let i = 0; i < n; ++i) {\n            const y0 = y[i];\n            const y1 = y[2 * n + i];\n            const yp0 = y[n + i];\n            const yp1 = y[3 * n + i];\n            const yDiff = y1 - y0;\n            const aspl = -yp1 + yDiff;\n            const bspl = yp0 - yDiff;\n            y[n + i] = yDiff;\n            y[2 * n + i] = aspl;\n            y[3 * n + i] = bspl;\n            if (imit < 0)\n                continue;\n            // compute the derivatives of Hermite at midpoint\n            const ph0 = (y0 + y1) * 0.5 + 0.125 * (aspl + bspl);\n            const ph1 = yDiff + (aspl - bspl) * 0.25;\n            const ph2 = -(yp0 - yp1);\n            const ph3 = 6 * (bspl - aspl);\n            // compute the further coefficients\n            if (imit >= 1) {\n                this.ap[1] = 16 * (y[5 * n + i] - ph1);\n                if (imit >= 3) {\n                    this.ap[3] = 16 * (y[7 * n + i] - ph3 + 3 * this.ap[1]);\n                    if (imit >= 5) {\n                        for (let im = 5; im <= imit; im += 2) {\n                            let fac1 = im * (im - 1) / 2;\n                            let fac2 = fac1 * (im - 2) * (im - 3) * 2;\n                            this.ap[im] = 16 * (y[(im + 4) * n + i] + fac1 * this.ap[im - 2] - fac2 * this.ap[im - 4]);\n                        }\n                    }\n                }\n            }\n            this.ap[0] = (y[4 * n + i] - ph0) * 16;\n            if (imit >= 2) {\n                this.ap[2] = (y[n * 6 + i] - ph2 + this.ap[0]) * 16;\n                if (imit >= 4) {\n                    for (let im = 4; im <= imit; im += 2) {\n                        let fac1 = im * (im - 1) / 2;\n                        let fac2 = im * (im - 1) * (im - 2) * (im - 3);\n                        this.ap[im] = (y[n * (im + 4) + i] + this.ap[im - 2] * fac1 - this.ap[im - 4] * fac2) * 16;\n                    }\n                }\n            }\n            for (let im = 0; im <= imit; ++im)\n                y[n * (im + 4) + i] = this.ap[im];\n        }\n    }\n    /**\n     * Given interpolation data, produce the dense output function over the solution\n     * segment [xOld, xOld+h].\n     */\n    contex(xOld, h, imit) {\n        const y = this.dens.slice();\n        return (c, x) => {\n            const nrd = this.options.denseComponents.length;\n            let i = this.options.denseComponents.indexOf(c);\n            if (i < 0)\n                throw new Error('no dense output available for component ' + c);\n            const theta = (x - xOld) / h;\n            const theta1 = 1 - theta;\n            const phthet = y[i] + theta * (y[nrd + i] + theta1 * (y[2 * nrd + i] * theta + y[3 * nrd + i] * theta1));\n            if (imit < 0)\n                return phthet;\n            const thetah = theta - 0.5;\n            let ret = y[nrd * (imit + 4) + i];\n            for (let im = imit; im >= 1; --im) {\n                ret = y[nrd * (im + 3) + i] + ret * thetah / im;\n            }\n            return phthet + Math.pow((theta * theta1), 2) * ret;\n        };\n    }\n    /**\n     * Computes the jth line of the extrapolation table (0-based) and\n     * provides an estimation of the optional step size. Returns\n     * false if the Fortran condition \"ATOV\" is true. Not quite\n     * sure what that stands for as of this writing.\n     * @param j\n     * @param h\n     * @param x\n     * @param y\n     * @param yprime\n     * @returns\n     */\n    midEx(j, h, x, y, yprime) {\n        const hj = h / this.nj[j];\n        // Euler starting step\n        for (let i = 0; i < this.n; ++i) {\n            this.yh1[i] = y[i];\n            this.yh2[i] = y[i] + hj * yprime[i];\n        }\n        // Explicit midpoint rule\n        const m = this.nj[j] - 1;\n        const njMid = (this.nj[j] / 2) | 0;\n        for (let mm = 1; mm <= m; ++mm) {\n            if (this.options.denseOutput && mm === njMid) {\n                for (let i = 0; i < this.options.denseComponents.length; ++i) {\n                    this.ySafe[j][i] = this.yh2[this.options.denseComponents[i]];\n                }\n            }\n            this.f(x + hj * mm, this.yh2, this.dy);\n            if (this.options.denseOutput && Math.abs(mm - njMid) <= 2 * j + 1) {\n                ++this.iPt;\n                for (let i = 0; i < this.options.denseComponents.length; ++i) {\n                    this.fSafe[this.iPt - 1][i] = this.dy[this.options.denseComponents[i]];\n                }\n            }\n            for (let i = 0; i < this.n; ++i) {\n                let ys = this.yh1[i];\n                this.yh1[i] = this.yh2[i];\n                this.yh2[i] = ys + 2 * hj * this.dy[i];\n            }\n            if (mm <= this.options.stabilityCheckCount && j < this.options.stabilityCheckTableLines) {\n                // stability check\n                let del1 = 0;\n                for (let i = 0; i < this.n; ++i) {\n                    del1 += Math.pow((yprime[i] / this.scal[i]), 2);\n                }\n                let del2 = 0;\n                for (let i = 0; i < this.n; ++i) {\n                    del2 += Math.pow(((this.dy[i] - yprime[i]) / this.scal[i]), 2);\n                }\n                const quot = del2 / Math.max(this.options.uRound, del1);\n                if (quot > 4) {\n                    ++this.nEval;\n                    return false;\n                }\n            }\n        }\n        // final smoothing step\n        this.f(x + h, this.yh2, this.dy);\n        if (this.options.denseOutput && njMid <= 2 * j + 1) {\n            ++this.iPt;\n            for (let i = 0; i < this.options.denseComponents.length; ++i) {\n                this.fSafe[this.iPt - 1][i] = this.dy[this.options.denseComponents[i]];\n            }\n        }\n        for (let i = 0; i < this.n; ++i) {\n            this.t[j][i] = (this.yh1[i] + this.yh2[i] + hj * this.dy[i]) / 2;\n        }\n        this.nEval += this.nj[j];\n        // polynomial extrapolation\n        if (j === 0)\n            return true;\n        let fac;\n        for (let l = j; l > 0; --l) {\n            fac = Math.pow((this.nj[j] / this.nj[l - 1]), 2) - 1;\n            for (let i = 0; i < this.n; ++i) {\n                this.t[l - 1][i] = this.t[l][i] + (this.t[l][i] - this.t[l - 1][i]) / fac;\n            }\n        }\n        this.err = 0;\n        // scaling\n        for (let i = 0; i < this.n; ++i) {\n            let t0i = Math.max(Math.abs(y[i]), Math.abs(this.t[0][i]));\n            this.scal[i] = this.aTol[i] + this.rTol[i] * t0i;\n            this.err += Math.pow(((this.t[0][i] - this.t[1][i]) / this.scal[i]), 2);\n        }\n        this.err = Math.sqrt(this.err / this.n);\n        if (this.err * this.options.uRound >= 1 || (j > 1 && this.err >= this.errOld)) {\n            return false;\n        }\n        this.errOld = Math.max(4 * this.err, 1);\n        // compute optimal stepsizes\n        let exp0 = 1 / (2 * j + 1);\n        let facMin = Math.pow(this.options.stepSizeFac1, exp0);\n        fac = Math.min(this.options.stepSizeFac2 / facMin, Math.max(facMin, Math.pow((this.err / this.options.stepSafetyFactor1), exp0) / this.options.stepSafetyFactor2));\n        fac = 1 / fac;\n        this.hh[j] = Math.min(Math.abs(h) * fac, this.hMax);\n        this.w[j] = this.a[j] / this.hh[j];\n        return true;\n    }\n    /**\n     * Considers accepting the current integration step, and, if dense output is\n     * requested, prepares the data that will be used by the interpolating function.\n     * If denseOutputErrorEstimator is also switched on, information gathered\n     * while preparing the dense output data may be used to tardily decide that\n     * the step should be rejected after all.\n     *\n     * @returns an object with the new optimized step size and either a dense\n     *     interpolation function or an indication that the step should be\n     *     rejected after all.\n     */\n    acceptStep(kc, h, x, y, dz) {\n        // label 60\n        const kmit = 2 * kc - this.options.interpolationFormulaDegree + 1;\n        let newHoptde = undefined;\n        if (this.options.denseOutput) {\n            const nrd = this.options.denseComponents.length;\n            // kmit = mu of the paper\n            for (let i = 0; i < nrd; ++i)\n                this.dens[i] = y[this.options.denseComponents[i]];\n            for (let i = 0; i < nrd; ++i)\n                this.dens[nrd + i] = h * dz[this.options.denseComponents[i]];\n            let kln = 2 * nrd;\n            for (let i = 0; i < nrd; ++i)\n                this.dens[kln + i] = this.t[0][this.options.denseComponents[i]];\n            // compute solution at mid-point\n            for (let j = 2; j <= kc; ++j) {\n                for (let l = j; l >= 2; --l) {\n                    let factor = Math.pow((this.nj[j - 1] / this.nj[l - 2]), 2) - 1;\n                    for (let i = 0; i < nrd; ++i) {\n                        this.ySafe[l - 2][i] = this.ySafe[l - 1][i] + (this.ySafe[l - 1][i] - this.ySafe[l - 2][i]) / factor;\n                    }\n                }\n            }\n            let krn = 4 * nrd;\n            for (let i = 0; i < nrd; ++i)\n                this.dens[krn + i] = this.ySafe[0][i];\n            // compute first derivative at right end\n            for (let i = 0; i < this.n; ++i)\n                this.t0i[i] = this.t[0][i];\n            this.f(x + h, this.t0i, this.fx);\n            krn = 3 * nrd;\n            for (let i = 0; i < nrd; ++i)\n                this.dens[krn + i] = this.fx[this.options.denseComponents[i]] * h;\n            // THE LOOP\n            for (let kmi = 1; kmi <= kmit; ++kmi) {\n                // compute kmi-th derivative at mid-point\n                let kbeg = (kmi + 1) / 2 | 0;\n                for (let kk = kbeg; kk <= kc; ++kk) {\n                    let facnj = Math.pow((this.nj[kk - 1] / 2), (kmi - 1));\n                    this.iPt = this.iPoint[kk] - 2 * kk + kmi;\n                    for (let i = 0; i < nrd; ++i) {\n                        this.ySafe[kk - 1][i] = this.fSafe[this.iPt - 1][i] * facnj; // TODO warning: if we change definition of iPoint, need to fix this\n                    }\n                }\n                for (let j = kbeg + 1; j <= kc; ++j) {\n                    for (let l = j; l >= kbeg + 1; --l) {\n                        let factor = Math.pow((this.nj[j - 1] / this.nj[l - 2]), 2) - 1;\n                        for (let i = 0; i < nrd; ++i) {\n                            this.ySafe[l - 2][i] = this.ySafe[l - 1][i] + (this.ySafe[l - 1][i] - this.ySafe[l - 2][i]) / factor;\n                        }\n                    }\n                }\n                krn = (kmi + 4) * nrd;\n                for (let i = 0; i < nrd; ++i)\n                    this.dens[krn + i] = this.ySafe[kbeg - 1][i] * h;\n                if (kmi === kmit)\n                    continue;\n                // compute differences\n                for (let kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                    let lbeg = this.iPoint[kk];\n                    let lend = this.iPoint[kk - 1] + kmi + 1;\n                    if (kmi === 1 && this.options.stepSizeSequence === 4)\n                        lend += 2;\n                    let l;\n                    for (l = lbeg; l >= lend; l -= 2) {\n                        for (let i = 0; i < nrd; ++i) {\n                            this.fSafe[l - 1][i] -= this.fSafe[l - 3][i];\n                        }\n                    }\n                    if (kmi === 1 && this.options.stepSizeSequence === 4) {\n                        l = lend - 2;\n                        for (let i = 0; i < nrd; ++i)\n                            this.fSafe[l - 1][i] -= dz[this.options.denseComponents[i]];\n                    }\n                }\n                // compute differences\n                for (let kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                    let lbeg = this.iPoint[kk] - 1;\n                    let lend = this.iPoint[kk - 1] + kmi + 2;\n                    for (let l = lbeg; l >= lend; l -= 2) {\n                        for (let i = 0; i < nrd; ++i) {\n                            this.fSafe[l - 1][i] -= this.fSafe[l - 3][i];\n                        }\n                    }\n                }\n            }\n            this.interp(this.dens, kmit);\n            // estimation of interpolation error\n            if (this.options.denseOutputErrorEstimator && kmit >= 1) {\n                let errint = 0;\n                for (let i = 0; i < nrd; ++i)\n                    errint += Math.pow((this.dens[(kmit + 4) * nrd + i] / this.scal[this.options.denseComponents[i]]), 2);\n                errint = Math.sqrt(errint / nrd) * this.errfac[kmit - 1];\n                newHoptde = h / Math.max(Math.pow(errint, (1 / (kmit + 4))), 0.01);\n                if (errint > 10) {\n                    ++this.nReject;\n                    return {\n                        accept: false,\n                        hoptde: newHoptde\n                    };\n                }\n            }\n            this.copy(dz, this.fx);\n        }\n        this.copy(y, this.t[0]);\n        ++this.nAccept;\n        return {\n            accept: true,\n            hoptde: newHoptde,\n            densef: this.options.denseOutput ? this.contex(x, h, kmit) : this.noDenseOutput\n        };\n    }\n    /**\n     * Compute new \"optimal\" extrapolation order and step size based on current\n     * integration conditions recorded in the work array `w`.\n     *\n     * @param reject true if the previous integration step was rejected\n     * @param kc current extrapolation column\n     * @param k extrapolation columns\n     * @param h previous step size\n     * @returns An object holding new step size and extrapolation order\n     */\n    newOrderAndStepSize(reject, kc, k, h) {\n        // compute optimal interpolation order\n        let kopt;\n        if (kc === 2) {\n            kopt = Math.min(3, this.options.maxExtrapolationColumns - 1);\n            if (reject)\n                kopt = 2;\n        }\n        else if (kc <= k) {\n            kopt = kc;\n            if (this.w[kc - 2] < this.w[kc - 1] * this.options.stepSizeFac3)\n                kopt = kc - 1;\n            if (this.w[kc - 1] < this.w[kc - 2] * this.options.stepSizeFac4)\n                kopt = Math.min(kc + 1, this.options.maxExtrapolationColumns - 1);\n        }\n        else {\n            kopt = kc - 1;\n            if (kc > 3 && this.w[kc - 3] < this.w[kc - 2] * this.options.stepSizeFac3)\n                kopt = kc - 2;\n            if (this.w[kc - 1] < this.w[kopt - 1] * this.options.stepSizeFac4)\n                kopt = Math.min(kc, this.options.maxExtrapolationColumns - 1);\n        }\n        // after a rejected step\n        if (reject) {\n            return {\n                k: Math.min(kopt, kc),\n                h: this.posNeg * Math.min(Math.abs(h), Math.abs(this.hh[k - 1]))\n            };\n        }\n        let r = { h: 0, k: 0 };\n        if (kopt <= kc) {\n            r.h = this.hh[kopt - 1];\n        }\n        else {\n            if (kc < k && this.w[kc - 1] < this.w[kc - 2] * this.options.stepSizeFac4) {\n                r.h = this.hh[kc - 1] * this.a[kopt] / this.a[kc - 1];\n            }\n            else {\n                r.h = this.hh[kc - 1] * this.a[kopt - 1] / this.a[kc - 1];\n            }\n        }\n        r.h = this.posNeg * Math.abs(r.h);\n        r.k = kopt;\n        return r;\n    }\n    /**\n     * Legacy interface, which delivers solution segments via callback.\n     * The callback will be invoked with the values `xOld`, `x`, `y`, and\n     * `f`. This represents the integration step of the interval `[xOld, x]`,\n     * where $y$ is the integrated value of $f(x)$, and (if dense output was\n     * requested) `f` can be used to obtain high quality results for $f(x)$\n     * anywhere in the interval `[xOld, x]`. It is illegal to use f outside\n     * this range.\n     *\n     * @param x0 initial independent variable\n     * @param y0 f(x0)\n     * @param xEnd end of integration interval\n     * @param solOut optional solution segment callback, or step handler\n     * @returns an object containing summary information about the integration\n     */\n    solve(x0, y0, xEnd, solOut) {\n        if (this.options.denseOutput && !solOut)\n            throw new Error('solve: denseOutput requires a solution observer function');\n        let lastY = y0;\n        for (let segment of this.solutionSegments(x0, y0, xEnd)) {\n            if (solOut) {\n                solOut(segment.x0, segment.x1, segment.y, segment.f);\n            }\n            lastY = segment.y;\n        }\n        return {\n            y: lastY,\n            nStep: this.nStep,\n            xEnd: xEnd,\n            nAccept: this.nAccept,\n            nReject: this.nReject,\n            nEval: this.nEval\n        };\n    }\n    /**\n     * Integrate the differential equation. This produces a function which will\n     * interpolate the solution as far as desired (starting at the point where\n     * the initial conditions are provided). The function must be invoked on an\n     * increasing sequence of x values: you cannot rewind the integration to an\n     * earlier point. (Behind the scenes, a variable step size integration\n     * algorithm is generating solution segments valid on finite intervals. As\n     * you move into a new interval, older intervals are discarded, allowing the\n     * integration to proceed indefinitely without accumulating memory).\n     *\n     * You can signal that you are through with the integrator by calling the\n     * interpolator function with no arguments.\n     *\n     * @param x0 initial independent variable\n     * @param y0 f(x0)\n     * @return interpolation function valid on a monotonically increasing\n     *     argument sequence\n     */\n    integrate(x0, y0) {\n        if (!this.options.denseOutput)\n            throw new Error('integrate interface requires denseOutput');\n        const components = this.options.denseComponents;\n        const segments = this.solutionSegments(x0, y0);\n        let s = segments.next();\n        let closed = false;\n        return (x, v) => {\n            if (x === undefined) {\n                segments.next(false);\n                closed = true;\n                return [];\n            }\n            else if (x < s.value.x0) {\n                throw new Error('cannot use interpolation function in backwards direction');\n            }\n            else if (closed) {\n                throw new Error('cannot use interpolation function after closing integrator');\n            }\n            else {\n                while (!s.done && x > s.value.x1)\n                    s = segments.next();\n                if (v !== undefined) {\n                    for (let i = 0; i < components.length; ++i)\n                        v[i] = s.value.f(components[i], x);\n                    return v;\n                }\n                else {\n                    let w = Array(components.length);\n                    for (let i = 0; i < components.length; ++i)\n                        w[i] = s.value.f(components[i], x);\n                    return w;\n                }\n            }\n        };\n    }\n    /**\n     * Integrate the differential system represented by f, given initial\n     * values x and y0 = f(x). This generates a contiguous sequence of\n     * solution segments. Each segment contains an interval [x0, x1] and\n     * the integrated value f(x1). If denseOutput is selected in the options,\n     * an interpolation function is provided, valid over the closed interval.\n     *\n     * @param x initial independent coordinate\n     * @param y0 initial value\n     * @param xEnd optional end of integration interval\n     * @return generates a sequence of objects containing x0, x1, y and f properties\n     */\n    *solutionSegments(x, y0, xEnd) {\n        var _a, _b;\n        if (!Array.isArray(y0) || y0.length != this.n)\n            throw new Error('y0 must be an array sized to the dimension of the problem');\n        let y = y0.slice();\n        this.hMax = this.options.maxStepSize;\n        if (this.options.maxStepSize) {\n            this.hMax = this.options.maxStepSize;\n        }\n        else if (xEnd) {\n            this.hMax = Math.abs(xEnd - x);\n        }\n        else {\n            this.hMax = 1;\n        }\n        this.nStep = this.nAccept = this.nReject = 0;\n        this.posNeg = xEnd ? (xEnd - x >= 0 ? 1 : -1) : 1;\n        // Initial Scaling\n        for (let i = 0; i < this.n; ++i) {\n            this.scal[i] = this.aTol[i] + this.rTol[i] + Math.abs(y[i]);\n        }\n        // Initial preparations\n        let k = Math.max(2, Math.min(this.options.maxExtrapolationColumns - 1, Math.floor(-Math.log10(this.rTol[0] + 1e-40) * 0.6 + 1.5)));\n        let h = Math.max(Math.abs(this.options.initialStepSize), 1e-4);\n        h = this.posNeg * Math.min(h, this.hMax, xEnd ? Math.abs(xEnd - x) / 2 : Infinity);\n        let xOld = x;\n        this.iPt = 0; // TODO: fix\n        if (this.options.denseOutput) {\n            this.iPoint[0] = 0;\n            for (let i = 0; i < this.options.maxExtrapolationColumns; ++i) {\n                let njAdd = 4 * (i + 1) - 2;\n                if (this.nj[i] > njAdd)\n                    ++njAdd;\n                this.iPoint[i + 1] = this.iPoint[i] + njAdd;\n            }\n            for (let mu = 0; mu < 2 * this.options.maxExtrapolationColumns; ++mu) {\n                let errx = Math.sqrt((mu + 1) / (mu + 5)) * 0.5;\n                let prod = Math.pow((1 / (mu + 5)), 2);\n                for (let j = 1; j <= mu + 1; ++j)\n                    prod *= errx / j;\n                this.errfac[mu] = prod;\n            }\n        }\n        this.err = 0;\n        this.errOld = 1e10;\n        let hoptde = this.posNeg * this.hMax;\n        let reject = false;\n        let last = false;\n        let kc = 0;\n        let state = STATE.Start;\n        loop: while (true) {\n            this.options.debug && console.log(`#${this.nStep} ${STATE[state]} [${xOld},${x}] h=${h} k=${k}`);\n            switch (state) {\n                case STATE.Start:\n                    if (xEnd !== undefined) {\n                        // Is xEnd reached in the next step?\n                        if (0.1 * Math.abs(xEnd - x) <= Math.abs(x) * this.options.uRound)\n                            break loop;\n                        h = this.posNeg * Math.min(Math.abs(h), Math.abs(xEnd - x), this.hMax, Math.abs(hoptde));\n                        if ((x + 1.01 * h - xEnd) * this.posNeg > 0) {\n                            h = xEnd - x;\n                            last = true;\n                        }\n                    }\n                    else {\n                        h = this.posNeg * Math.min(Math.abs(h), this.hMax, Math.abs(hoptde));\n                    }\n                    if (this.nStep === 0 || !this.options.denseOutput) {\n                        this.f(x, y, this.dz);\n                        ++this.nEval;\n                    }\n                    // The first and last step\n                    if (this.nStep === 0 || last) {\n                        this.iPt = 0;\n                        ++this.nStep;\n                        for (let j = 1; j <= k; ++j) {\n                            kc = j;\n                            if (!this.midEx(j - 1, h, x, y, this.dz)) {\n                                h *= this.options.stepSizeReductionFactor;\n                                reject = true;\n                                continue loop;\n                            }\n                            if (j > 1 && this.err <= 1) {\n                                state = STATE.Accept;\n                                continue loop;\n                            }\n                        }\n                        state = STATE.HopeForConvergence;\n                        continue;\n                    }\n                    state = STATE.BasicIntegrationStep;\n                    continue;\n                case STATE.BasicIntegrationStep:\n                    // basic integration step\n                    this.iPt = 0;\n                    if (++this.nStep >= this.options.maxSteps) {\n                        throw new Error('maximum allowed steps exceeded: ' + this.nStep);\n                    }\n                    kc = k - 1;\n                    for (let j = 0; j < kc; ++j) {\n                        if (!this.midEx(j, h, x, y, this.dz)) {\n                            h *= this.options.stepSizeReductionFactor;\n                            reject = true;\n                            state = STATE.Start;\n                            continue loop;\n                        }\n                    }\n                    // convergence monitor\n                    if (k === 2 || reject) {\n                        state = STATE.ConvergenceStep;\n                    }\n                    else {\n                        if (this.err <= 1) {\n                            state = STATE.Accept;\n                        }\n                        else if (this.err > Math.pow(((this.nj[k] * this.nj[k - 1]) / 4), 2)) {\n                            state = STATE.Reject;\n                        }\n                        else\n                            state = STATE.ConvergenceStep;\n                    }\n                    continue;\n                case STATE.ConvergenceStep: // label 50\n                    if (!this.midEx(k - 1, h, x, y, this.dz)) {\n                        h *= this.options.stepSizeReductionFactor;\n                        reject = true;\n                        state = STATE.Start;\n                        continue;\n                    }\n                    kc = k;\n                    if (this.err <= 1) {\n                        state = STATE.Accept;\n                        continue;\n                    }\n                    state = STATE.HopeForConvergence;\n                    continue;\n                case STATE.HopeForConvergence:\n                    // hope for convergence in line k + 1\n                    if (this.err > Math.pow((this.nj[k] / 2), 2)) {\n                        state = STATE.Reject;\n                        continue;\n                    }\n                    kc = k + 1;\n                    if (!this.midEx(kc - 1, h, x, y, this.dz)) {\n                        h *= this.options.stepSizeReductionFactor;\n                        reject = true;\n                        state = STATE.Start;\n                    }\n                    else if (this.err > 1)\n                        state = STATE.Reject;\n                    else\n                        state = STATE.Accept;\n                    continue;\n                case STATE.Accept:\n                    const result = this.acceptStep(kc, h, x, y, this.dz);\n                    state = STATE.Start;\n                    hoptde = (_a = result.hoptde) !== null && _a !== void 0 ? _a : hoptde;\n                    if (!result.accept) {\n                        h = hoptde;\n                        reject = true;\n                        continue;\n                    }\n                    // Move forward\n                    xOld = x;\n                    x += h;\n                    const proceed = yield {\n                        x0: xOld,\n                        x1: x,\n                        y: y.slice(),\n                        f: (_b = result.densef) !== null && _b !== void 0 ? _b : this.noDenseOutput\n                    };\n                    if (proceed === false) {\n                        // Client has signaled that they are through with the integration\n                        // and so no further segments will be needed.\n                        return;\n                    }\n                    ({ k, h } = this.newOrderAndStepSize(reject, kc, k, h));\n                    reject = false;\n                    continue;\n                case STATE.Reject:\n                    k = Math.min(k, kc, this.options.maxExtrapolationColumns - 1);\n                    if (k > 2 && this.w[k - 1] < this.w[k] * this.options.stepSizeFac3)\n                        k -= 1;\n                    ++this.nReject;\n                    h = this.posNeg * this.hh[k - 1];\n                    reject = true;\n                    state = STATE.BasicIntegrationStep;\n            }\n        }\n    }\n}\nexports.Solver = Solver;\nSolver.defaults = {\n    uRound: 2.3e-16,\n    maxSteps: 10000,\n    initialStepSize: 1e-4,\n    maxStepSize: 0,\n    maxExtrapolationColumns: 9,\n    stepSizeSequence: 0,\n    stabilityCheckCount: 1,\n    stabilityCheckTableLines: 2,\n    denseOutput: true,\n    denseOutputErrorEstimator: true,\n    denseComponents: [],\n    interpolationFormulaDegree: 4,\n    stepSizeReductionFactor: 0.5,\n    stepSizeFac1: 0.02,\n    stepSizeFac2: 4.0,\n    stepSizeFac3: 0.8,\n    stepSizeFac4: 0.9,\n    stepSafetyFactor1: 0.65,\n    stepSafetyFactor2: 0.94,\n    relativeTolerance: 1e-5,\n    absoluteTolerance: 1e-5,\n    debug: false,\n    rawFunction: false,\n};\n//# sourceMappingURL=odex.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}